# 题目汇总

[toc]

## 1.二分查找五道题

第一题：寻找旋转排序数组中的最小值，详见 leetcode 153。

> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
>
> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
>
> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
>
> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。



第二题：x的平方根，详见 leetcode 69。

> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。
>
> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**
>
> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

```go
// 从查找区间返回最后一个值
func mySqrt(x int) int {
	// 查找区间[0,x]
	left, right := 0, x
	for left <= right {
		mid := left + (right-left)/2
		v := mid * mid
		if v > x {  // 需要舍弃掉的
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return right
}
```



第三题：搜索旋转排序数组，详见 leetcode 33。

> 整数数组 nums 按升序排列，数组中的值 互不相同 。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
>
> 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```go
// 二分查找
func search(nums []int, target int) int {
	res := -1
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right-left)/2
		if nums[mid] == target {
			return mid
		}
		// 前半段有序
		if nums[left] <= nums[mid] {
			if nums[left] <= target && target < nums[mid] {
				right = mid - 1 // search [left, mid-1]
			} else {
				left = mid + 1 // search [mid+1, right]
			}
		} else {
			// 后半段有序
			if nums[mid] < target && target <= nums[right] {
				left = mid + 1 // search [mid+1, right]
			} else {
				right = mid - 1 // search [left, mid-1]
			}
		}
	}

	return res
}
```





## 2.回溯算法五道题

第一题：全排列，详见leetcode 46。

> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。



第二题：组合总和，详见 leetcode 39。

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。





第三题：组合总和2，详见 leetcode 40。

> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
>
> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。
>
> **注意：**解集不能包含重复的组合。



第四题：括号生成，详见 leetcode 22。

> 给定数字 n，设计一个函数生成所有可能且有效的括号组合。

解法：回溯算法，分别添加左右括号。



## 3.二叉树五道题

第一题：非递归前序，中序、后序遍历二叉树。



第二题：二叉树的最大路径和，详见 124 题。

> 二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。
>
> **路径和** 是路径中各节点值的总和。
>
> 给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

注意，这道题里的路径可以不经过根节点，也没有要求路径的起点和终点一定是叶子节点。



第三题：打家劫舍3-二叉树版

> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。
>
> 除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。
>
> 给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

这个问题的关键在于定义 DFS 函数的时候，要同时返回包含根节点和不包含根节点两种场景下可获得的最大值。



第四题：将二叉搜索树转化为排序后的双向链表

> 将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。
>
> 对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
>
> 特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

这个题目的关键在于理解递归版的中序遍历，注意前驱节点的记录和更新。



第五题：路径总和问题，详见 leetcode 112。

> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
>
> **叶子节点** 是指没有子节点的节点。

解法：携带目标匹配值进行 DFS。



## 4.动态规划五道题

第一题：爬楼梯，详见 leetcode 70。

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？



第二题：最长回文子串，详见 leetcode 5。

> 给你一个字符串 `s`，找到 `s` 中最长的回文子串。
>
> 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

解法：双指针。



第三题：买卖股票的最佳时机，详见 leetcode 121。

> 给定价格数组，只能交易一次，求可获得的最大利润。

解法：维护一个低价变量，正序遍历，计算利润，并更新结果。



第四题：买卖股票的最佳时间2，详见 leetcode 122。

> 给定价格数组，可以交易多次，求可获得的最大利润。

解法：可交易多次，直接求前后价格差即可。



第五题：打家劫舍，详见 leetcode 198。

> 给定每个房屋里的金额大小，求可偷窃的最大金额。
>
> 约束条件：相邻的房屋不能同时偷。

解法：递推公式如下：

```go
// dp[i] 第i天可偷取的最大金额
dp[i] = max(dp[i-1], dp[i-2]+nums[i])
```



第六题：编辑距离，详见 leetcode 72。

> 给定两个字符串，你可以插入、删除、替换一个字符，求将 word1 变成 word2 的的最小操作数。

解法：两层循环，依次比较两个字符串中的字符，递归公式如下：

```go
if word1[i] == word2[j]
	dp[i][j] = dp[i-1][j-1]
else
	dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
```





第七题：最长公共子序列，详见 leetcode 1143。

> 给定两个字符串，求最长公共子序列。

解法：两层循环，依次比较两个字符串各个位置上的字符，递推公式如下：

```go
if text1[i] == text2[j]
	lcs[i][j] = lcs[i-1][j-1] + 1
else
	lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])
```





## 5.字符串五道题

第一题：无重复字符的最长子串，详见 leetcode 3。

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串的长度。

解法：滑动窗口。



第二题：最长回文子串，详见 leetcode 5。

> 给定一个字符串，返回其中最长的回文子串。

解法：双指针，从中心到两边。



第三题：



## 6.图的五道题

第一题：课程表，详见 leetcode 207。

> 给定课程总数和先修依赖关系，问是否可在满足先修依赖关系的情况下修完所有课程。

解法：AOV网络，拓扑排序。

第二题：课程表4，详见 leetcode 1462。

> 给定课程总数和先修依赖关系，再给到一组课程依赖查询表，输出查询表的结果。

解法：aov网络拓扑排序，在排序过程中重建两两课程之间的依赖关系。
