# 题目汇总

[toc]

## 二分查找五道题

第一题：寻找旋转排序数组中的最小值，详见 leetcode 153。

> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
>
> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
>
> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
>
> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。



第二题：x的平方根，详见 leetcode 69。

> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。
>
> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**
>
> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

```go
// 从查找区间返回最后一个值
func mySqrt(x int) int {
	// 查找区间[0,x]
	left, right := 0, x
	for left <= right {
		mid := left + (right-left)/2
		v := mid * mid
		if v > x {  // 需要舍弃掉的
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return right
}
```



第三题：搜索旋转排序数组，详见 leetcode 33。

> 整数数组 nums 按升序排列，数组中的值 互不相同 。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
>
> 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```go
// 二分查找
func search(nums []int, target int) int {
	res := -1
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right-left)/2
		if nums[mid] == target {
			return mid
		}
		// 前半段有序
		if nums[left] <= nums[mid] {
			if nums[left] <= target && target < nums[mid] {
				right = mid - 1 // search [left, mid-1]
			} else {
				left = mid + 1 // search [mid+1, right]
			}
		} else {
			// 后半段有序
			if nums[mid] < target && target <= nums[right] {
				left = mid + 1 // search [mid+1, right]
			} else {
				right = mid - 1 // search [left, mid-1]
			}
		}
	}

	return res
}
```





## 回溯算法五道题

第一题：全排列，详见leetcode 46。

> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。



第二题：组合总和，详见 leetcode 39。

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。





第三题：组合总和2，详见 leetcode 40。

> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
>
> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。
>
> **注意：**解集不能包含重复的组合。



## 二叉树五道题

第一题：非递归前序，中序、后序遍历二叉树。

第二题：二叉树的最大路径和，详见 124 题。

> 二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。
>
> **路径和** 是路径中各节点值的总和。
>
> 给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

注意，这道题里的路径可以不经过根节点，也没有要求路径的起点和终点一定是叶子节点。



```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 前序遍历
func preorderTraversal(root *TreeNode) []int {
	// root, left, right
	ans := make([]int, 0, 16)
	if root == nil {
		return ans
	}

	stack := make([]*TreeNode, 0, 16)
	for root != nil || len(stack) != 0 {
		for root != nil {
			ans = append(ans, root.Val)
			stack = append(stack, root)
			root = root.Left
		}
		if len(stack) != 0 {
			root = stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			root = root.Right
		}
	}

	return ans
}

// 中序遍历
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
	// left, root, right
	ans := make([]int, 0, 16)
	if root == nil {
		return ans
	}

	stack := make([]*TreeNode, 0, 16)

	for root != nil || len(stack) != 0 {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		if len(stack) != 0 {
			cur := stack[len(stack)-1]
			ans = append(ans, cur.Val)
			stack = stack[:len(stack)-1]
			root = cur.Right
		}
	}

	return ans
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
	ans := make([]int, 0, 16)
	if root == nil {
		return ans
	}
	// left, right, root

	stack := make([]*TreeNode, 0, 16)
	stack = append(stack, root)

	var cur, pre *TreeNode

	for len(stack) != 0 {
		cur = stack[len(stack)-1]
		if cur.Left == nil && cur.Right == nil {
			ans = append(ans, cur.Val)
			stack = stack[:len(stack)-1]
			pre = cur
		} else if pre != nil && (pre == cur.Left || pre == cur.Right) {
			ans = append(ans, cur.Val)
			stack = stack[:len(stack)-1]
			pre = cur
		} else {
			if cur.Right != nil {
				stack = append(stack, cur.Right)
			}
			if cur.Left != nil {
				stack = append(stack, cur.Left)
			}
		}
	}

	return ans
}
// 第二题
// date 2024/01/16
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
    ans := math.MinInt32

    var bfs func(root *TreeNode) int
    bfs = func(root *TreeNode) int {
        if root == nil {
            return 0
        }
      	// 如果左右子树的总和为负数，可以不加入路径
        left := max(bfs(root.Left), 0)
        right := max(bfs(root.Right), 0)
        
        sum := root.Val + left + right
        ans = max(ans, sum)

        return root.Val + max(left, right)
    }

    bfs(root)

    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

