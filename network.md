## 计算机网络
----

协议地图

![image-20210307174221779](./images/image-20210307174221779.png)

### 二层设备

----

二层设备是工作数据链路层的设备。二层交换机可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：
（1） 当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；
（2） 再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；
（3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；
（4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。
　　不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。

### ARP协议

ARP协议，即地址解析协议，将 IP 解析在 MAC 地址

RARP协议，即逆地址解析协议，将 MAC 地址映射为 IP。

![image-20210307165207712](./images/image-20210307165207712.png)

链接：http://www.023wg.com/message/message/cd_feature_ARP_message_format.html

ARP请求：

1. dst mac 为 `ff:ff:ff:ff:ff:ff`，即广播报文
2. arp 请求中包含发送端的 ip 和 mac，这样接收端收到后可以建立自己的 ARP 表

ARPy应答：

1. 单播报文，dst mac 为 arp 请求中 sender mac，src mac 为自身mac
2. 携带信息为 `sender mac` 和 `sender ip`  为自身信息，`target mac` 和 `target ip` 为 arp 请求中的 sender

所以，arp请求报文为广播报文，而arp应答为单播报文。

> ARP工作在第几层

1）从功能上来讲，ARP服务于数据链路层；2）从数据包的封装和解封装来看，ARP属于第三层，网络层；3）MPLS层，即2.5层。

> 什么是代理ARP

当 ARP 请求目标跨网段时，网关设备收到 ARP 请求，会用自己的 MAC 地址返回给请求者，这就是代理ARP。

当主机没有网关时，采用代理ARP；当主机有网关时，采用正常ARP。

### 三层设备

----


### TCP/UDP
----

TCP header结构

![image-20210307160552646](./images/image-20210307160552646.png)

![image-20210307160844229](./images/image-20210307160844229.png)

> 1、TCP三次握手和四次挥手

**三次握手**流程图

![See the source image](./images/v2-58da9aba1e37a69dc909aef0e77081fb_b.png)

详细说明：

第一次握手

Client什么都没有确认

Server确认Client发送正常

第二次握手：

Client确认自己发送/接收正常，对方发送/接收正常

Server确认自己接收正常，Client发送正常

第三次握手：

Server确认自己发送/接收正常，Client发送/接收正常

因此，三次握手最重要的就是保证连接是双工。



**四次挥手流程图**

![See the source image](./images/tcp-four-handshakes.png)

> 为什么建立连接是三次，而关闭连接是四次？

1）建立连接， Server 收到 SYN=1 后，把 ACK， SYN 放到一个数据包里发送给Client

2）关闭连接，当收到对方 FIN 包，表示对方不再发送数据，但是还能接收数据，这个时候还允许发送数据到对方，当数据确认已经发送完毕时，才向对方发送 FIN 包。所以 ACK 和 FIN 包是分开的。

> 3、为什么要有TIME_WAIT状态

![See the source image](./images/tcp_status.png)

TIME_WAIT状态是主动关闭的一方，在发送最后一个 ACK 后进入`time_wait`状态，然后保持 2MSL 时间才能回到初始状态。

MSL是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。

1）为实现TCP全双工连接的可靠释放

假设发起主动关闭的一方（client）最后发送的 ACK 在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。

2）为使旧的数据包在网络因过期而消失

为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。

> 、为什么会有UDP协议

UDP 是面向无链接的不可靠传输。

一个重要的原因是**IP协议中并没有端口(port)**的概念。IP协议进行的是 IP 到 IP 地址的传输，两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用。**一个端口就代表了这样的一个通信通道**。UDP协议实现了端口，从而让数据包可以在送到IP地址的基础上，进一步可以送到某个端口。

在使用TCP协议传输数据时，如果一个数据段丢失或者接收端对某个数据段没有确认，发送端会重新发送该数据段。TCP重新发送数据会带来传输延迟和重复数据，降低了用户的体验。**对于迟延敏感的应用，少量的数据丢失一般可以被忽略，这时使用UDP传输将能够提升用户的体验**。

> 5、为什么UDP需要长度字段，而TCP不需要？

![img](https://pic3.zhimg.com/80/v2-4e650c82d033a0319c3f63ea501fd3fc_720w.jpg?source=1940ef5c)

翻译一下就是：**UDP length字段是冗余的，它等于IP total length 减去IP header。**

长度字段是多余的，因为IP标头和UDP标头都具有长度字段。我唯一想到这种冗余的原因是，发生这种情况是因为UDP是一次设计的，目前尚不清楚IP协议套件的外观。

所有合法的UDP数据包都应具有一个长度字段，该长度字段与IP报头中的长度字段可以精确地匹配。如果您不这样做，则无法确定接收方将如何处理数据包。

长度字段不一致的

UDP数据包在Internet上很常见。我猜他们正在探测缓冲区溢出，如果将一个长度字段用于分配内存，而将另一个长度字段用于将数据复制到分配的缓冲区时，则可能会发生这种情况。

在较新的UDP Lite协议中，长度字段已被重新利用。 UDP Lite报头中的length字段并不指示数据包中有多少数据，而是指示校验和已覆盖了其中的多少数据。 UDP Lite数据包中的数据长度始终是根据IP标头中的长度字段计算的。这是UDP和UDP Lite标头格式之间的唯一区别。

> 、TCP的流量控制

*什么是流量控制？流量控制的目的？*

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。

流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

*如何实现流量控制？*

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

> 7、流量控制引发的死锁*？*怎么避免死锁的发生*？

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了**持续计时器**。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。



### VXLAN技术

VXLAN 是一种常见的网络虚拟化技术，其原理是将Ethernet帧封装在 UDP 中，加上8 字节的 vxlan 头部，从而标识不同的二层网络。

vxlan 数据包由 VTEP (Vxlan Tunnel EndPoint)进行封装和解封装。

vxlan header 结构

![image-20210307171227490](./images/image-20210307171227490.png)

1 个字节等于 8 个比特位。vxlan header 结构说明：

前 8 个 bit 位为 Flags 字段，`I` 必须置为 1 ，代表 VNI 有效；24bit 的 VXLAN Network Identifier 为 overlay 网络标识号；其他Reserved字段必须置为 0 。

$$ 2^{24} = 16 * 2^{20} = 16 M$$

所以，vxlan共支持1600万个不同的二层网络。



经常与vxlan一起对比的是vlan，下面我们看下vlan的header结构

vlan 是直接在 Ethernet 帧头部增加 4 个字节的 `vlan tag`， 用于表示不同的二层网络。

vlan header结构

![image-20210307172707467](./images/image-20210307172707467.png)

`PRI` 3bit，表示帧的优先级，值越大优先级越高；

`CFI (Canonical Format Indicator)` 1bit，表示MAC地址是否是经典格式。CFI为0说明是标准格式，CFI为1表示为非标准格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。在以太网中，CFI的值为0。

`VID` 12bit，表示帧所属的vlan，三个特殊的VID：

- 0x000：设置优先级但无VID
- 0x001：缺省VID
- 0xFFF：预留VID

$$ 2^{12} = 4096 $$ 即最大支持4096（除去特殊VID，即4094）个不同的二层网络

> 为什么要用VXLAN?

1）vlan ID的限制，vlan 4096个，vxlan 16M个，但是如果用802.1 AD QinQ协议，即加 2 个vlan tag，总共也有16M个不同的二层网络。

2）交换机 MAC 表的问题

vlan将带来 mac 表暴增，而vxlan将二层帧放在UDP数据包中，其外层的二三层信息相对固定

3）虚机的迁移和部署

vxlan 是在L3 网络上构建了 L2 网络，物理网络二层边界还在，但是虚机的网络数据在三层传输，可以跨越物理网络二层的限制。

4）vlan 无法做负载均衡，使用 STP 管理多条线路；而 vxlan 在三层传输，可以作负载均衡

> vxlan 和 vlan的最大区别

vlan 只是修改了原始的 Ethernet 帧，整个数据包还是原来的数据包；但是 vxlan 将原始的 Ethernet 帧隐藏在了 UDP 数据包中，从网络中只看到 VTEP 间，UDP 数据的传输。

参考资料：

vxlan RFC 7348 https://tools.ietf.org/html/rfc7348

Vlan http://www.023wg.com/message/message/cd_feature_eth_vlan.html

### HTTP/HTTPS

----

> 1、http与https的区别

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较好。
- HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

> 2、https的加密过程

HTTPS加密过程：

1. 客户端请求服务器获取 **证书公钥**
2. 客户端(SSL/TLS)解析证书（无效会弹出警告）
3. 生成随机值
4. 用**证书公钥**随机值生成**密钥**
5. 客户端将**密钥**发送给服务器
6. 服务端用**私钥**解密**密钥**得到随机值【4，5，6非对称加密/解密】
7. 将信息和随机值混合在一起，进行对称加密
8. 将加密的内容发送给客户端
9. 客户端用**密钥**解密信息

参考资料：https://segmentfault.com/a/1190000019976390

> 3、http协议

- HTTP (Hypertext transfer protocol) 超文本传输协议
- HTTP 协议在 7 层传输架构中属于应用层协议，其依赖 TCP 协议
- HTTP 协议由请求和响应两部分组成，是一个标准的客户端服务器模型
- HTTP 默认端口号 80，https 默认端口号 443
- HTTP 协议通过 URL（统一资源定位符 - Uniform-Resource-Locator）来定位互联网上的资源地址
- HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持长连接，无状态指的是 HTTP 不具备事务记忆能力，也就是下一次的请求不会记住上一次的请求信息。
- HTTP 协议 0.9 和 1.0 版本使用非持续性连接，也就是一次请求一次响应，连接就会关闭，而从 HTTP 协议 1.1 开始，默认开启了 Keep-Alive，保持长连接，就是说一次请求结束后，连接不会马上关闭，下一次请求会继续使用这个连接，但长连接不代表一直不关闭，一段时间后这个连接就会关闭。



### BGP协议

BGP协议，即边界网关协议，其定义为核心，去中心化自洽路由协议。

BGP 协议既支持应用在一个 AS 内部，也支持应用在 AS 间。AS 内部为 `iBGP` 协议，AS 间为 `eBGP` 协议。

BGP header 结构

![image-20210307174647291](./images/image-20210307174647291.png)

BGP 数据类型，分四种

- Open

TCP 连接建立后，bgp 发送的第一个报文，bgp peer 回 keepalive 确认 Open

- Update

首次，交换整个BGP router table；之后只发送变化了的路由

- Notification

出错时发送的消息，一旦发送，bgp 会中断

- Keepalive

只有 header 信息，bgp session hold time。

>iBGP 和 eBGP的区别

传递路由时，对 `next-hop` 处理不同，`eBGP` 修改路由 `next-hop` 再转发，目的是为了将流量引入自己；而 `iBGP` 不修改，直接转发。