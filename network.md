## 计算机网络

### 二层设备

二层设备是工作数据链路层的设备。二层交换机可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：
（1） 当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；
（2） 再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；
（3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；
（4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。
　　不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。

### 三层设备



### TCP/UDP

1、TCP三次握手和四次挥手

2、为什么要有TIME_WAIT状态

3、为什么会有UDP协议

4、TCP的流量控制

*什么是流量控制？流量控制的目的？*

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。

流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

*如何实现流量控制？*

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

*流量控制引发的死锁*？*怎么避免死锁的发生*？

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

### HTTP/HTTPS

1、http与https的区别

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较好。
- HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

2、https的加密过程

HTTPS加密过程：

1. 客户端请求服务器获取 **证书公钥**
2. 客户端(SSL/TLS)解析证书（无效会弹出警告）
3. 生成随机值
4. 用**证书公钥**随机值生成**密钥**
5. 客户端将**密钥**发送给服务器
6. 服务端用**私钥**解密**密钥**得到随机值【4，5，6非对称加密/解密】
7. 将信息和随机值混合在一起，进行对称加密
8. 将加密的内容发送给客户端
9. 客户端用**密钥**解密信息

参考资料：https://segmentfault.com/a/1190000019976390

3、http协议

- HTTP (Hypertext transfer protocol) 超文本传输协议
- HTTP 协议在 7 层传输架构中属于应用层协议，其依赖 TCP 协议
- HTTP 协议由请求和响应两部分组成，是一个标准的客户端服务器模型
- HTTP 默认端口号 80，https 默认端口号 443
- HTTP 协议通过 URL（统一资源定位符 - Uniform-Resource-Locator）来定位互联网上的资源地址
- HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持长连接，无状态指的是 HTTP 不具备事务记忆能力，也就是下一次的请求不会记住上一次的请求信息。
- HTTP 协议 0.9 和 1.0 版本使用非持续性连接，也就是一次请求一次响应，连接就会关闭，而从 HTTP 协议 1.1 开始，默认开启了 Keep-Alive，保持长连接，就是说一次请求结束后，连接不会马上关闭，下一次请求会继续使用这个连接，但长连接不代表一直不关闭，一段时间后这个连接就会关闭。