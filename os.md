## 操作系统

## 要点

### 进程

进程是一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需要的状态组成（包括内存中程序的数据和代码，调用栈，寄存器，程序计数器，环境变量，文件描述符等集合）。

进程给应用程序提供了两个关键的抽象：

 - 一个独立的逻辑控制流	
   	- 一个逻辑流的执行在时间上和另一个流重叠，称为并发流。【更准确地说，流 X 和流 Y 互相并发，当且仅当 X 在 Y 开始之后 和 Y 结束之前开始，或者 Y 在 X 开始之后 和 X 结束之前开始。】
   	- 一个进程和其他进程轮流运行的概念成为**多任务**。
   	- 一个进程执行它的控制流的一部分的每一时间段叫做**时间片**。
   	- 如果两个流在时间上重叠，那么它们就是并发的。【在时间上重叠的意思是流 X 和 流 Y 在开始和结束的时间段内有重叠】

- 一个私有的地址空间
  - 地址空间底部是保留给用户程序的
  - 地址空间顶部是保留给内核
  - 以32位Linux系统为例，其寻址空间为4G，其中最高的1G字节给内核用，称为内核空间，最低的3G字节给用户使用，称为用户空间。

**需要注意的细节问题：**

1. 内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 

2. Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。

**内核态与用户态：**

1. **当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。**此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

2. **当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）**。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

### 上下文切换/进程切换

上下文就是内核重新启动一个被抢占的进程所需的状态。

在进程执行的某个时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策就叫做**调度**。

调度通过上下文切换实现，上下文切换 1）保存当前进程的上下文，2 ）恢复某个先前被抢占的进程被保存的上下文， 3 ）将控制传递给这个新恢复的进程。

进程切换中几个最重要的步骤：

1. 当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。
2. 操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。
3. 从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令

#### 进程阻塞

上图展示了一个进程的不同状态：

- New. 进程正在被创建.
- Running. 进程的指令正在被执行
- Waiting. 进程正在等待一些事件的发生（例如 I/O 的完成或者收到某个信号）
- Ready. 进程在等待被操作系统调度
- Terminated. 进程执行完毕（可能是被强行终止的）

我们所说的 “阻塞”是指进程在**发起了一个系统调用**（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为**等待 （waiting）**状态， 以确保它不会被调度执行， 占用 CPU 资源。

### 并发

最简单和最基本的并发，是指两个或两个以上 **独立** 的活动，**同时** 发生。计算机中并发的两种方式包括：**多核处理器的真正并行** 和 **单核处理器的任务切换**；其基本实现途径也有三种：**基于进程并发**，**基于I/O多路复用并发** 和 **基于线程并发**。通常，多进程并发具有以下优势：1）操作系统在进程间提供的附加保护操作和更高级别的通信机制，可以更容易编写安全的代码；2）可以使用远程连接的方式在不同的机器上运行独立的代码。

进程是由内核自动调度的，而且具有独立的虚拟内存空间，要实现数据共享，必须显式地IPC机制。

事件驱动程序创建它们自己的并发逻辑流，逻辑流被模型化为状态机，用I/O多路复用来显式地调度这些逻辑流。因为程序运行在一个单一进程中，所以流之间共享数据速度很快而且容易。

线程是这些方法的结合。同基于进程的流一样，线程也是有内核自动调度的。同基于I/O多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便的共享数据。

#### 基于进程的并发编程

服务器端在接收客户端连接请求之后，服务器派生一个子进程(子进程获得服务器描述符表的完整副本)。注意：**子进程关闭它的副本中的监听描述符，而父进程关闭已连接的描述符**。(因为父、子进程中的已连接描述符都指向同一个文件表表项，所以父进程关闭已连接描述符的副本至关重要。否则，将永远不会释放已连接描述符的文件表条目，而由此引起的内存泄漏将最终耗尽可用内存，是系统崩溃。)

优劣：

1）父、子进程间共享状态信息，其模型是：共享文件表，但是不共享用户地址空间。进程有独立的地址空间，可避免一个进程覆盖另一个进程的虚拟内存。

2）独立的地址空间使得进程共享状态信息变得困难。为了共享状态信息，必须使用显式的IPC机制。

#### 基于I/O多路复用

I/O多路复用解决的问题是**服务器必须响应两个独立的 I/O事件**。

I/O多路复用技术的基本思想是使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序。

#### 基于线程的并发编程

线程同步就是当多个线程共享相同的内存时，当某个线程可以修改变量，而其他线程也可以读取或修改这个变量的时候，就需要对这些线程进行同步，以确保他们在访问变量的存储内容时不会访问到无效的数值。”，确保同步的措施是在操作前进行加锁。

**互斥锁**：通常提供互斥为目的的二元信号量称为互斥锁。在一个互斥锁上执行P操作称为对互斥锁加锁，执行V操作称为对互斥锁解锁。其关键思想是，**P操作和V操作的结合创建了一组状态，叫禁止区。** 对互斥量进行加锁后，任何其他试图再对该互斥量加锁的线程都会被阻塞直到当前持有锁的线程释放锁。

**互斥锁加锁解锁顺序规则**:给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

读写锁, “当读写锁是写加锁时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。
当读写锁是读加锁时，在这个锁被解锁之前，所有试图以读模式对他进行加锁的线程都可以得到访问权”。

在并发线程中，多个线程需要对共享资源进行访问。一个线程利用信号量操作来通知另一个线程，程序状态中的某个条件是否为真。这种方式称为 *运用信号量调度共享资源*。两个经典的例子是 **生产者-消费者** 和 **读-写者** 问题。

**生产者-消费者** 问题

因为插入和取出项目都涉及更新共享变量，必须保证对缓冲区的访问是 **互斥的**，并且还需要 **调度** 缓冲区的访问。如果缓冲区是满状态，则生产者必须等待直到缓冲区变得有槽位可用；如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。

**读-写者** 问题

读-写者问题是互斥问的一个概括。修改对象的线程称为 **写者**，只读取对象的线程称为 **读者**。**写者必须拥有对对象的独占访问，而读者可以与无限多个其他的读者共享对象**。

读写者问题的几个变种。1）读者优先。要求不让读者等待，除非已经把使用对象的权限赋予了一个写者。读者不会因为写者在等待而等待。**但是，可能会导致饥饿，即写者线程出现无线等待的情况**。2）写者优先。要求一旦一个写者准备好写操作，写者线程尽可能快地完成写操作。即在一个写者后到达的读者必须等待，即使写者也在等待。



### 参考资料

1、链接：https://www.jianshu.com/p/722819425dbd



1、零拷贝是什么原理？



2、fork 的流程？



3、select/poll/epoll 的区别？

|            | select                                             | poll                                             | Epoll                                                        |
| ---------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 操作方式   | 遍历                                               | 遍历                                             | 回调                                                         |
| 底层实现   | 数组                                               | 链表                                             | 哈希表                                                       |
| IO效率     | 每次调用都进行线性遍历，时间复杂度为O(n)           | 每次调用都进行线性遍历，时间复杂度为O(n)         | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1) |
| 最大连接数 | 1024（x86）或 2048（x64）                          | 无上限                                           | 无上限                                                       |
| fd拷贝     | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝    |

select：https://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html

poll：https://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html

Epoll（event poll）：https://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html

三者的对比和区别：https://www.cnblogs.com/Anker/p/3265058.html

